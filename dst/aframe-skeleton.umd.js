!function(t,e){"object"==typeof exports&&"undefined"!=typeof module?e(require("three")):"function"==typeof define&&define.amd?define(["three"],e):e((t="undefined"!=typeof globalThis?globalThis:t||self).THREE)}(this,(function(t){"use strict";const e=new t.Vector3,i=new t.Vector3,o=new t.Vector3,s=new t.Matrix4;function n(t,e){return e.setFromMatrixPosition(t.matrixWorld)}const r=new t.Vector3(0,1,0);class a{constructor(e,{constraints:i}={}){this.constraints=i||[],this.bone=e,this.distance=0,this._originalDirection=new t.Vector3,this._originalHinge=new t.Vector3,this._direction=new t.Vector3,this._worldPosition=new t.Vector3,this._isSubBase=!1,this._subBasePositions=null,this.isIKJoint=!0,this._originalUp=new t.Vector3(0,1,0),this._originalUp.applyQuaternion(this.bone.quaternion).normalize(),this._updateWorldPosition()}_setIsSubBase(){this._isSubBase=!0,this._subBasePositions=[]}_applySubBasePositions(){0!==this._subBasePositions.length&&(!function(t,e){e.set(0,0,0);for(let i of t)e.add(i);e.divideScalar(t.length)}(this._subBasePositions,this._worldPosition),this._subBasePositions.length=0)}_applyConstraints(){if(!this.constraints)return;let t=!1;for(let e of this.constraints)if(e&&e._apply){let i=e._apply(this);t=t||i}return t}_setDistance(t){this.distance=t}_getDirection(){return this._direction}_setDirection(t){this._direction.copy(t)}_getDistance(){return this.distance}_updateMatrixWorld(){this.bone.updateMatrixWorld(!0)}_getWorldPosition(){return this._worldPosition}_getWorldDirection(e){return(new t.Vector3).subVectors(this._getWorldPosition(),e._getWorldPosition()).normalize()}_updateWorldPosition(){n(this.bone,this._worldPosition)}_setWorldPosition(t){this._worldPosition.copy(t)}_localToWorldDirection(t){if(this.bone.parent){const e=this.bone.parent.matrixWorld;t.transformDirection(e)}return t}_worldToLocalDirection(e){if(this.bone.parent){const i=(new t.Matrix4).getInverse(this.bone.parent.matrixWorld);e.transformDirection(i)}return e}_applyWorldPosition(){let n=(new t.Vector3).copy(this._direction),a=(new t.Vector3).copy(this._getWorldPosition());if(this.bone.parent){this._updateMatrixWorld(),!function(t,e,i){const o=e.elements,s=t.x*o[0]+t.y*o[4]+t.z*o[8]+o[12],n=t.x*o[1]+t.y*o[5]+t.z*o[9]+o[13],r=t.x*o[2]+t.y*o[6]+t.z*o[10]+o[14],a=t.x*o[3]+t.y*o[7]+t.z*o[11]+o[15];i.set(s/a,n/a,r/a)}(a,(new t.Matrix4).getInverse(this.bone.parent.matrixWorld),a),this.bone.position.copy(a),this._updateMatrixWorld(),this._worldToLocalDirection(n),function(t,n,r){const a=e,h=i,l=o,c=s,d=s.elements;l.copy(t),a.crossVectors(n,l),0===a.lengthSq()&&(1===Math.abs(n.z)?l.x+=1e-4:l.z+=1e-4,l.normalize(),a.crossVectors(n,l)),a.normalize(),h.crossVectors(l,a),d[0]=a.x,d[4]=h.x,d[8]=l.x,d[1]=a.y,d[5]=h.y,d[9]=l.y,d[2]=a.z,d[6]=h.z,d[10]=l.z,r.setFromRotationMatrix(c)}(n,r,this.bone.quaternion)}else this.bone.position.copy(a);this.bone.updateMatrix(),this._updateMatrixWorld()}_getWorldDistance(e){return this._worldPosition.distanceTo(e.isIKJoint?e._getWorldPosition():n(e,new t.Vector3))}}class h extends t.Object3D{constructor(e,i,o){if(super(),0!==e){const o=new t.ConeBufferGeometry(i,e,4);o.applyMatrix((new t.Matrix4).makeRotationAxis(new t.Vector3(1,0,0),Math.PI/2)),this.boneMesh=new t.Mesh(o,new t.MeshBasicMaterial({color:16711680,wireframe:!0,depthTest:!1,depthWrite:!1}))}else this.boneMesh=new t.Object3D;this.boneMesh.position.z=e/2,this.add(this.boneMesh),this.axesHelper=new t.AxesHelper(o),this.add(this.axesHelper)}}class l extends t.Object3D{constructor(e,{color:i,showBones:o,boneSize:s,showAxes:n,axesSize:r,wireframe:a}={}){if(super(),s=s||.1,r=r||.2,!e.isIK)throw new Error("IKHelper must receive an IK instance.");this.ik=e,this._meshes=new Map;for(let t of this.ik.chains){const e=[t];for(;e.length;){const i=e.shift();for(let e=0;e<i.joints.length;e++){const o=i.joints[e],n=i.joints[e+1],a=n?n.distance:0;if(i.base===o&&i!==t)continue;const l=new h(a,s,r);l.matrixAutoUpdate=!1,this._meshes.set(o,l),this.add(l)}for(let t of i.chains.values())for(let i of t)e.push(i)}}this.showBones=void 0===o||o,this.showAxes=void 0===n||n,this.wireframe=void 0===a||a,this.color=i||new t.Color(16711799)}get showBones(){return this._showBones}set showBones(t){if(t!==this._showBones){for(let[e,i]of this._meshes)t?i.add(i.boneMesh):i.remove(i.boneMesh);this._showBones=t}}get showAxes(){return this._showAxes}set showAxes(t){if(t!==this._showAxes){for(let[e,i]of this._meshes)t?i.add(i.axesHelper):i.remove(i.axesHelper);this._showAxes=t}}get wireframe(){return this._wireframe}set wireframe(t){if(t!==this._wireframe){for(let[e,i]of this._meshes)i.boneMesh.material&&(i.boneMesh.material.wireframe=t);this._wireframe=t}}get color(){return this._color}set color(e){if(!this._color||!this._color.equals(e)){e=e&&e.isColor?e:new t.Color(e);for(let[t,i]of this._meshes)i.boneMesh.material&&(i.boneMesh.material.color=e);this._color=e}}updateMatrixWorld(t){for(let[t,e]of this._meshes)e.matrix.copy(t.bone.matrixWorld);super.updateMatrixWorld(t)}}class c{constructor(){this.chains=[],this._needsRecalculated=!0,this.isIK=!0,this._orderedChains=null}add(t){if(!t.isIKChain)throw new Error("Argument is not an IKChain.");this.chains.push(t)}recalculate(){this._orderedChains=[];for(let t of this.chains){const e=[];this._orderedChains.push(e);const i=[t];for(;i.length;){const t=i.shift();e.push(t);for(let e of t.chains.values())for(let t of e){if(-1!==i.indexOf(t))throw new Error("Recursive chain structure detected.");i.push(t)}}}}solve(){this._orderedChains||this.recalculate();for(let t of this._orderedChains){let e=1;for(;e>0;){for(let e=t.length-1;e>=0;e--)t[e]._updateJointWorldPositions();for(let e=t.length-1;e>=0;e--)t[e]._forward();let i=!0;for(let e=0;e<t.length;e++){t[e]._backward()>this.tolerance&&(i=!1)}if(i)break;e--}}}getRootBone(){return this.chains[0].base.bone}}new t.Vector3(0,0,-1),new t.Vector3(1,0,0),new t.Vector3,new t.Vector3,new t.Vector3,new t.Vector3;class d{constructor(){this.isIKChain=!0,this.totalLengths=0,this.base=null,this.effector=null,this.effectorIndex=null,this.chains=new Map,this.origin=null,this.iterations=100,this.tolerance=.01,this._depth=-1,this._targetPosition=new t.Vector3}add(e,{target:i}={}){if(this.effector)throw new Error("Cannot add additional joints to a chain with an end effector.");if(e.isIKJoint||(e=new a(e)),this.joints=this.joints||[],this.joints.push(e),1===this.joints.length)this.base=this.joints[0],this.origin=(new t.Vector3).copy(this.base._getWorldPosition());else{const i=this.joints[this.joints.length-2],o=this.joints[this.joints.length-3];i._updateMatrixWorld(),i._updateWorldPosition(),e._updateWorldPosition();const s=i._getWorldDistance(e);if(0===s)throw new Error("bone with 0 distance between adjacent bone found");e._setDistance(s),e._updateWorldPosition();const n=i._getWorldDirection(e);i._originalDirection=(new t.Vector3).copy(n),e._originalDirection=(new t.Vector3).copy(n),o&&(i._originalHinge=i._worldToLocalDirection(i._originalDirection.clone().cross(o._originalDirection).normalize())),this.totalLengths+=s}return i&&(this.effector=e,this.effectorIndex=e,this.target=i),this}_hasEffector(){return!!this.effector}_getDistanceFromTarget(){return this._hasEffector()?this.effector._getWorldDistance(this.target):-1}connect(t){if(!t.isIKChain)throw new Error("Invalid connection in an IKChain. Must be an IKChain.");if(!t.base.isIKJoint)throw new Error("Connecting chain does not have a base joint.");const e=this.joints.indexOf(t.base);if(this.target&&e===this.joints.length-1)throw new Error("Cannot append a chain to an end joint in a chain with a target.");if(-1===e)throw new Error("Cannot connect chain that does not have a base joint in parent chain.");this.joints[e]._setIsSubBase();let i=this.chains.get(e);return i||(i=[],this.chains.set(e,i)),i.push(t),this}_updateJointWorldPositions(){for(let t of this.joints)t._updateWorldPosition()}_forward(){if(this.origin.copy(this.base._getWorldPosition()),this.target)this._targetPosition.setFromMatrixPosition(this.target.matrixWorld),this.effector._setWorldPosition(this._targetPosition);else if(!this.joints[this.joints.length-1]._isSubBase)return;for(let t=1;t<this.joints.length;t++){const e=this.joints[t];e._isSubBase&&e._applySubBasePositions()}for(let t=this.joints.length-1;t>0;t--){const e=this.joints[t],i=this.joints[t-1],o=i._getWorldDirection(e).multiplyScalar(e.distance).add(e._getWorldPosition());i===this.base&&this.base._isSubBase?this.base._subBasePositions.push(o):i._setWorldPosition(o)}}_backward(){this.base._isSubBase||this.base._setWorldPosition(this.origin);for(let t=0;t<this.joints.length-1;t++){const e=this.joints[t],i=this.joints[t+1],o=e._getWorldPosition(),s=i._getWorldDirection(e);e._setDirection(s),e._applyConstraints(),s.copy(e._direction),this.base===e&&e._isSubBase||e._applyWorldPosition(),i._setWorldPosition(s.multiplyScalar(i.distance).add(o)),t===this.joints.length-2&&(i!==this.effector&&i._setDirection(s),i._applyWorldPosition())}return this._getDistanceFromTarget()}}const f=new t.Vector3(0,0,1),{DEG2RAD:_,RAD2DEG:u}=t.Math;class p{constructor(t){this.angle=t}_apply(e){const i=(new t.Vector3).copy(e._getDirection()),o=e._localToWorldDirection((new t.Vector3).copy(f)).normalize(),s=i.angleTo(o)*u;if(this.angle/2<s){i.normalize();const s=(new t.Vector3).crossVectors(o,i).normalize();return o.applyAxisAngle(s,this.angle*_*.5),e._setDirection(o),!0}return!1}}AFRAME.registerComponent("skeletor",{schema:{ball:{type:"number",default:void 0},hinge:{type:"number",default:void 0},target:{type:"selector"},root:{type:"bool",default:!1},debug:{type:"bool",default:!0}},update(){this.data.target&&setTimeout(()=>{this.ik=new c,this.chain=new d;let t=this.el;const e=[this.data.target,t];for(;!t.components.bone.data.root;)t=t.parentNode,e.push(t);let i;this.root=t.components.bone.root;for(let o=e.length-1;o>=0;o--){t=e[o];const{ball:s,hinge:n}=t.components.bone?t.components.bone.data:{},r=[];s&&r.push(new p(s)),n&&r.push(new IKHingeConstraint(n)),i=new a(t.object3D,{constraints:r}),this.chain.add(i,{target:0===o?this.data.target.object3D:null})}this.ik.add(this.chain),this.data.debug&&(this.helper=new l(this.ik,{boneSize:.1,axesSize:.1,showBones:!0,showAxes:!0}),this.el.sceneEl.object3D.add(this.helper))},1e3)},tick(){this.ik&&this.ik.solve()},remove(){this.ik&&(this.el.object3D.remove(this.ik),this.data.debug&&setTimeout(()=>{this.el.sceneEl.object3D.remove(this.helper),delete this.helper},500))}})}));
//# sourceMappingURL=aframe-skeleton.umd.js.map
